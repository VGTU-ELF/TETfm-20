Debesų kompiuterija

[.text-center]
=== Laboratorinis darbas nr. 3

[.text-center]
== Susipažinimas su Kubernetes platforma

[.text-left]
=== Darbo tikslas

* Išbandyti `Kubernetes` platformą
* Atlikti pagrindinius veiksmus su `Kubernetes` resursais.

[.text-left]
=== Užduotis

. Puslapyje *https://www.katacoda.com/courses/kubernetes[Learn Kubernetes using Interactive Browser-Based Labs | Katacoda]* susikurkite paskyrą.
. Atlikite šias užduotis:
  * Čia naudosite `Minicube` -- tai įrankis, kuriuo lengva pakeisti `Kubernetes`.
    `Minicube` paleidžia vieno mazgo `Kubernetes` klasterį virtualioje mašinoje nešiojamame kompiuteryje naudotojams, 
    norintiems išbandyti `Kubernetes` arba kurti su ja kasdien:
    - https://www.katacoda.com/courses/kubernetes/launch-single-node-cluster[Launch Single Node Kubernetes Cluster]
  * Šiame scenarijuje sužinosite, kaip naudoti `Kubectl`, 
    kad sukurtumėte ir paleistumėte diegimo, replikavimo valdiklius 
    ir pateiktumėte juos per paslaugas (angl. _Services_) be papildomų `yaml` konfigūracijų.
    Tai leidžia konteinerius greitai startuoti klasteryje.
    - https://www.katacoda.com/courses/kubernetes/kubectl-run-containers[Deploy Containers Using Kubectl]
  * Šiame scenarijuje sužinosite, kaip naudoti `Kubectl`, kad sukurtumėte ir startuotumėte diegimo, replikavimo valdiklius
    ir pateiktumėte juos per paslaugas (angl. _Services_) aprašydami `yaml` apibrėžtis.
    `YAML` aprašo `Kubernetes` objektus.
    - https://www.katacoda.com/courses/kubernetes/creating-kubernetes-yaml-definitions[Deploy Containers Using YAML]
  * Šiame scenarijuje paaiškinama, kaip paleisti paprastą daugiapakopę žiniatinklio programą naudojant `Kubernetes` ir `Docker`:
    - https://www.katacoda.com/courses/kubernetes/guestbook[Deploy Guestbook example on Kubernetes]

Ataskaitos turinys:

  * Aprašyti pasiekti  rezultatai kiekvienoje užduotyje.
  * Failo dydis < 5 MiB, formatas `PDF`.


<<<

== Darbo eiga

=== Scenarijus nr. 1: "*Launch Single Node Kubernetes Cluster*"

  * Trumpas aprašymas

_Minikube_ -- įrankis pradėti naudotis Kubernetes lokaliai, bet produkcinio tinklo.
Jis virtualioje mašinoje (VM) startuoja vienanodį (angl. _single-node_) Kubernetes klasterį ir tinka asmeniniam kompiuteriui.
Skirtas naudotojams, siekiantiems išmėginti Kubernetes ar net vykdyti kasdienį sistemų kūrimą Kubernetes pagrindu.

  * Žingsnis 1.1: *startuojame `Minikube`*

    - patikriname versiją:
+
----
$ minikube version
minikube version: v1.8.1
commit: cbda04cf6bbe65e987ae52bb393c10099ab62014
----
image::https://asciinema.org/a/452640.svg[link="https://asciinema.org/a/452640?autoplay=1"]
+
{nbsp}


    - startuojame VM su `Kubernetes` klasteriu
+
----
$ minikube start --wait=false
* minikube v1.8.1 on Ubuntu 18.04
* Using the none driver based on user configuration
* Running on localhost (CPUs=2, Memory=2460MB, Disk=145651MB) ...
* OS release is Ubuntu 18.04.4 LTS
* Preparing Kubernetes v1.17.3 on Docker 19.03.6 ...
  - kubelet.resolv-conf=/run/systemd/resolve/resolv.conf
* Launching Kubernetes ... 
* Enabling addons: default-storageclass, storage-provisioner
* Configuring local host environment ...
* Done! kubectl is now configured to use "minikube"
----
image::https://asciinema.org/a/452643.svg[link="https://asciinema.org/a/452643?autoplay=1"]
+
{nbsp}


  * Žingsnis 1.2: *tikriname Kubernetes klasterio informaciją*

    - rodome klasterio būseną:
+
----
$ kubectl cluster-info
Kubernetes master is running at https://172.17.0.86:8443
KubeDNS is running at https://172.17.0.86:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
----
image::https://asciinema.org/a/452671.svg[link="https://asciinema.org/a/452671?autoplay=1"]
+
{nbsp}


    - klasterio nodų sąrašas:
+
----
$ kubectl get nodes
NAME       STATUS     ROLES    AGE   VERSION
minikube   NotReady   master   16s   v1.17.3

$ kubectl get nodes
NAME       STATUS   ROLES    AGE   VERSION
minikube   Ready    master   18s   v1.17.3
----
image::https://asciinema.org/a/452686.svg[link="https://asciinema.org/a/452686?autoplay=1"]
+
{nbsp}


  * Žingsnis 1.3: *diegiame konteinerį klasteryje*

    - konteinerio diegimas iš atvaizdo:
+
----
$ kubectl create deployment first-deployment --image=katacoda/docker-http-server
deployment.apps/first-deployment created
----
image::https://asciinema.org/a/452688.svg[link="https://asciinema.org/a/452688?autoplay=1"]
+
{nbsp}


    - tikriname diegimo būseną:
+
----
$ kubectl get pods
NAME                               READY   STATUS              RESTARTS   AGE
first-deployment-666c48b44-92c2z   0/1     ContainerCreating   0          3s

$ kubectl get pods
NAME                               READY   STATUS              RESTARTS   AGE
first-deployment-666c48b44-92c2z   0/1     ContainerCreating   0          4s

$ kubectl get pods
NAME                               READY   STATUS    RESTARTS   AGE
first-deployment-666c48b44-92c2z   1/1     Running   0          5s
----
image::https://asciinema.org/a/452708.svg[link="https://asciinema.org/a/452708?autoplay=1"]
+
{nbsp}


    - paviešiname konteinerį tinkle:
+
----
$ kubectl expose deployment first-deployment --port=80 --type=NodePort
service/first-deployment exposed
----
image::https://asciinema.org/a/452709.svg[link="https://asciinema.org/a/452709?autoplay=1"]
+
{nbsp}


    - susirandame alokuotą TCP-portą ir vykdome HTTP-užklausą:
+
----
$ kubectl get svc first-deployment -o go-template='{{range.spec.ports}}{{if .nodePort}}{{.nodePort}}{{"\n"}}{{end}}{{end}}'
31900

$ export PORT=$(kubectl get svc first-deployment -o go-template='{{range.spec.ports}}{{if .nodePort}}{{.nodePort}}{{"\n"}}{{end}}{{end}}')

$ echo "Accessing host01:$PORT"
Accessing host01:31900

$ curl host01:$PORT
<h1>This request was processed by host: first-deployment-666c48b44-92c2z</h1>
----
image::https://asciinema.org/a/452711.svg[link="https://asciinema.org/a/452711?autoplay=1"]
+
{nbsp}


  * Žingsnis 1.4: *_Kubernetes Dashboard_ sąsaja (web-UI)*

    - įgaliname _Minicube_ priedą _Dashboard_:
+
----
$ minikube addons enable dashboard
* The 'dashboard' addon is enabled
----
image::https://asciinema.org/a/452714.svg[link="https://asciinema.org/a/452714?autoplay=1"]
+
{nbsp}


    - diegiame _Kubernetes Dashboard_ pagal duotą YAML šabloną:
+
----
$ kubectl apply -f /opt/kubernetes-dashboard.yaml
namespace/kubernetes-dashboard configured
service/kubernetes-dashboard-katacoda created
----
image::https://asciinema.org/a/452718.svg[link="https://asciinema.org/a/452718?autoplay=1"]
+
{nbsp}


    - patikriname šablono turinį:
+
----
$ ls -l /opt/kubernetes-dashboard.yaml
-rw-r--r-- 1 root root 588 Mar  8  2020 /opt/kubernetes-dashboard.yaml

$ cat /opt/kubernetes-dashboard.yaml
apiVersion: v1
kind: Namespace
metadata:
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    kubernetes.io/minikube-addons: dashboard
  name: kubernetes-dashboard
  selfLink: /api/v1/namespaces/kubernetes-dashboard
spec:
  finalizers:
  - kubernetes
status:
  phase: Active
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: kubernetes-dashboard
  name: kubernetes-dashboard-katacoda
  namespace: kubernetes-dashboard
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 9090
    nodePort: 30000
  selector:
    k8s-app: kubernetes-dashboard
  type: NodePort
----
+
{nbsp}

    - stebime _Dashboard_ konteinerių startą:
+
----
$ kubectl get pods -n kubernetes-dashboard -w
NAME                                         READY   STATUS              RESTARTS   AGE
dashboard-metrics-scraper-7b64584c5c-7x46c   0/1     ContainerCreating   0          1s
kubernetes-dashboard-79d9cd965-7f5pb         0/1     ContainerCreating   0          1s
kubernetes-dashboard-79d9cd965-7f5pb         1/1     Running             0          1s
dashboard-metrics-scraper-7b64584c5c-7x46c   1/1     Running             0          2s
^C
$ 
----
image::https://asciinema.org/a/452725.svg[link="https://asciinema.org/a/452725?autoplay=1"]
+
{nbsp}


    - tikriname web-UI sąsają tiesiogiai:  +
      https://2886795274-30000-cykoria04.environments.katacoda.com/
      
      ** klasterio apžvalga:
+
image::https://user-images.githubusercontent.com/74717106/149772492-a72b5b07-9c09-463d-885a-3c4b81b31ff5.png[]
+
{nbsp}

      ** vardų srities apkrovos apžvalga:
+
image::https://user-images.githubusercontent.com/74717106/149772830-d20b2b96-3d10-432b-9d8a-78e34f04c4bc.png[]
+
{nbsp}

      ** bandomojo diegimo būsena:
+
image::https://user-images.githubusercontent.com/74717106/149774966-f3c803b3-7b9e-489d-9b82-a23e78d2c663.png[]
+
{nbsp}

      ** jo „ankšties“ būsena:
+
image::https://user-images.githubusercontent.com/74717106/149775048-a056fe1e-126f-4371-a9f9-88859feb2f34.png[]
+
{nbsp}

      ** paslaugų būsena, apkrovos balansavimas:
+
image::https://user-images.githubusercontent.com/74717106/149773732-aaf5f1c9-3c28-44e1-8fc6-05c5f44bf709.png[]
---
image::https://user-images.githubusercontent.com/74717106/149773955-ef7a3c7a-6826-4ca5-9723-f40e949fe007.png[]
---
image::https://user-images.githubusercontent.com/74717106/149774143-436458fd-7075-48cd-bcd2-21c7f464f4ba.png[]
+
{nbsp}

      ** vardų srities konfigūracija ir talpinimas:
+
image::https://user-images.githubusercontent.com/74717106/149774278-d7afe893-5549-47e7-a9fa-d3f51b425ab7.png[]
---
image::https://user-images.githubusercontent.com/74717106/149774439-804af510-6baa-4663-8037-56476357ddc9.png[]
+
{nbsp}


  * Reziume #1:

    - Panaudojau `minikube` bei `kubectl` komandas (jų subkomandas) ir:
    
      . startavau vieno nodo Kubernetes miniklasterį;  +
        (atskiroje VM, pasak gido)
      . patikrinau klasterio būseną: veikiantis;
      . sukūriau konteinerį pagal `katacoda/docker-http-server` atvaizdą;  +
        (tik vaizdo įraše padariau klaidą įterpdamas vieną papildomą raidę: `kataco**n**da`)
      . patikrinau diegimo „ankštį“: ji susikūrė konteinerį ir veikia;
      . paviešinau konteinerinę paslaugą tinkle atskiru `31900/TCP` portu;
      . prisijungiau šiuo portu su `curl` ir patikrinau paslaugos būseną: veikia;
      . įdiegiau ir startavau _Minicube_ priedą -- Web sąsają _Dashboard_
      . bei patikrinau klasterio būseną joje naudodamasis savo naršykle.  +
        (Nuoroda Web prisijungimui pateikė pats _katacoda.com_ gidas)

    - _Dashboard_ interfeisas _Overview_ skiltyje pasirenka `default` vardų sritį (_Namespace_):
      . joje nematyti savo paties „ankščių“ (_Pods_):  +
    `kubernetes-dashboard-79d9cd965-7f5pb`,  +
    `dashboard-metrics-scraper-7b64584c5c-7x46c`
      . jos tampa matomos pasirinkus `All namespaces` vardų sritį.
    

<<<

=== Scenarijus nr. 2: "*Deploy containers using Kubectl*"

  * Trumpas aprašymas

Mokinsimės _Kubectl_ pagalba kurti ir startuoti įdiegimus, replikavimo valdiklius ir viešinti juos kaip paslaugas.
Čia nenaudosime YAML apibrėžčių.
Šis būdas klasteryje įgalina sparčiai pradėti konteinerius kūrimą ir jų vykdymą.


  * Žingsnis 2.1: *startuojame Kubernetes klasterį*

    - startuojame klasterį ir įgaliname Kubectl CLI:
+
----
$ minikube start --wait=false
* minikube v1.8.1 on Ubuntu 18.04
* Using the none driver based on user configuration

* Running on localhost (CPUs=2, Memory=2460MB, Disk=145651MB) ...
* OS release is Ubuntu 18.04.4 LTS

* Preparing Kubernetes v1.17.3 on Docker 19.03.6 ...
  - kubelet.resolv-conf=/run/systemd/resolve/resolv.conf
* Launching Kubernetes ... 

* Enabling addons: default-storageclass, storage-provisioner
* Configuring local host environment ...
* Done! kubectl is now configured to use "minikube"
$ 
----
image::https://asciinema.org/a/462314.svg[link="https://asciinema.org/a/462314?autoplay=1"]
+
{nbsp}


    - patikriname nodo būseną:
+
----
$ kubectl get nodes
NAME       STATUS     ROLES    AGE   VERSION
minikube   NotReady   master   15s   v1.17.3
$ 
$ kubectl get nodes
NAME       STATUS   ROLES    AGE   VERSION
minikube   Ready    master   23s   v1.17.3
$ 
----
image::https://asciinema.org/a/462317.svg[link="https://asciinema.org/a/462317?autoplay=1"]
+
{nbsp}


  * Žingsnis 2.2: *vykdome `kubectl` ir `run`*
  
    - sukuriame įdiegimą ir startuojame jo „ankštis“ bei konteinerius:
+
----
$ kubectl run http --image=katacoda/docker-http-server:latest --replicas=1 
kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.
deployment.apps/http created
$ 
----
image::https://asciinema.org/a/462319.svg[link="https://asciinema.org/a/462319?autoplay=1"]
+
{nbsp}


    - tikriname įdiegimų būsenas:
+
----
$ kubectl get deployments
NAME   READY   UP-TO-DATE   AVAILABLE   AGE
http   0/1     1            0           35s
$ 
$ kubectl get deployments
NAME   READY   UP-TO-DATE   AVAILABLE   AGE
http   0/1     1            0           39s
$ 
$ kubectl get deployments
NAME   READY   UP-TO-DATE   AVAILABLE   AGE
http   0/1     1            0           42s
$ 
$ kubectl get deployments
NAME   READY   UP-TO-DATE   AVAILABLE   AGE
http   0/1     1            0           47s
$ 
$ kubectl get deployments
NAME   READY   UP-TO-DATE   AVAILABLE   AGE
http   1/1     1            1           55s
$ 
----
image::https://asciinema.org/a/462320.svg[link="https://asciinema.org/a/462320?autoplay=1"]
+
{nbsp}


    - tikriname išsamų įdiegimo aprašą:
+
----
$ kubectl describe deployment http
Name:                   http
Namespace:              default
CreationTimestamp:      Mon, 17 Jan 2022 18:02:36 +0000
Labels:                 run=http
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               run=http
Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  run=http
  Containers:
   http:
    Image:        katacoda/docker-http-server:latest
    Port:         <none>
    Host Port:    <none>
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  <none>
NewReplicaSet:   http-774bb756bb (1/1 replicas created)
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  76s   deployment-controller  Scaled up replica set http-774bb756bb to 1
$ 
----
image::https://asciinema.org/a/462321.svg[link="https://asciinema.org/a/462321?autoplay=1"]
+
{nbsp}


  * Žingsnis 2.3: *vykdome `kubectl` ir `expose`*
  
    - sukuriame paslaugą paviešindami konkretų konteinerio portą:
+
----
$ kubectl expose deployment http --external-ip="172.17.0.11" --port=8000 --target-port=80
service/http exposed
$ 
----
image::https://asciinema.org/a/462325.svg[link="https://asciinema.org/a/462325?autoplay=1"]
+
{nbsp}


    - patikriname paslaugos veikimą:
+
----
$ curl http://172.17.0.11:8000
<h1>This request was processed by host: http-774bb756bb-bbvm9</h1>
$ 
----
image::https://asciinema.org/a/462326.svg[link="https://asciinema.org/a/462326?autoplay=1"]
+
{nbsp}


  * Žingsnis 2.4: *vykdome `kubectl` ir `run`+`expose` iškart*
  
    - sukuriame naują įdiegimą ir paviešiname naują paslaugą kitu portu vienu ypu, kitu būdu:
+
----
$ kubectl run httpexposed --image=katacoda/docker-http-server:latest --replicas=1 --port=80 --hostport=8001
kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.
deployment.apps/httpexposed created
$ 
----
image::https://asciinema.org/a/462331.svg[link="https://asciinema.org/a/462331?autoplay=1"]
+
{nbsp}


    - patikriname naujos paslaugos veikimą:
+
----
$ curl http://172.17.0.11:8001
<h1>This request was processed by host: httpexposed-68cb8c8d4-d9b6w</h1>
$ 
----
image::https://asciinema.org/a/462333.svg[link="https://asciinema.org/a/462333?autoplay=1"]
+
{nbsp}


    - tikriname, ar naujas portas tikrai neatsirado paslaugų sąraše:
+
----
$ kubectl get svc
NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
http         ClusterIP   10.96.205.142   172.17.0.11   8000/TCP   19m
kubernetes   ClusterIP   10.96.0.1       <none>        443/TCP    39m
$ 
----
image::https://asciinema.org/a/462336.svg[link="https://asciinema.org/a/462336?autoplay=1"]
+
{nbsp}


    - tikriname, ar naujas portas atsirado tos pačios „ankšties“ tinkliniame konteineryje `pause`:  +
      (per _Docker Port Mapping_ mechanizmą)
+
----
$ docker ps | grep httpexposed
5945f9a4fa9b        katacoda/docker-http-server   "/app"                   10 minutes ago      Up 10 minutes                              k8s_httpexposed_httpexposed-68cb8c8d4-d9b6w_default_f2718b05-501c-4158-8d8e-0e4a62e99db9_0
6cc613c77542        k8s.gcr.io/pause:3.1          "/pause"                 10 minutes ago      Up 10 minutes       0.0.0.0:8001->80/tcp   k8s_POD_httpexposed-68cb8c8d4-d9b6w_default_f2718b05-501c-4158-8d8e-0e4a62e99db9_0
$ 
$ # OK
$ 
$ docker ps | wc -l
21
----
image::https://asciinema.org/a/462338.svg[link="https://asciinema.org/a/462338?autoplay=1"]
+
{nbsp}


  * Žingsnis 2.5: *dauginame konteinerius*

    - pakeliame „ankščių“ skaičių iki 3:
+
----
$ kubectl scale --replicas=3 deployment http
deployment.apps/http scaled
$ 
----
image::https://asciinema.org/a/462340.svg[link="https://asciinema.org/a/462340?autoplay=1"]
+
{nbsp}


    - tikriname „ankščių“ būsenas:
+
----
$ kubectl get pods
NAME                          READY   STATUS    RESTARTS   AGE
http-774bb756bb-bbvm9         1/1     Running   0          43m
httpexposed-68cb8c8d4-d9b6w   1/1     Running   0          18m
$ 
$ kubectl get pods
NAME                          READY   STATUS    RESTARTS   AGE
http-774bb756bb-bbvm9         1/1     Running   0          51m
http-774bb756bb-jcbgf         1/1     Running   0          7m50s
http-774bb756bb-qvqkc         1/1     Running   0          7m50s
httpexposed-68cb8c8d4-d9b6w   1/1     Running   0          26m
----
image::https://asciinema.org/a/462341.svg[link="https://asciinema.org/a/462341?autoplay=1"]
+
{nbsp}


    - tikriname, ar „ankštys“ pateko į apkrovos balansavimą šiai paslaugai:
+
----
$ kubectl describe svc http
Name:              http
Namespace:         default
Labels:            run=http
Annotations:       <none>
Selector:          run=http
Type:              ClusterIP
IP:                10.96.205.142
External IPs:      172.17.0.11
Port:              <unset>  8000/TCP
TargetPort:        80/TCP
Endpoints:         172.18.0.4:80,172.18.0.6:80,172.18.0.7:80
Session Affinity:  None
Events:            <none>
$ 
----
image::https://asciinema.org/a/462343.svg[link="https://asciinema.org/a/462343?autoplay=1"]
+
{nbsp}


    - atliekame kelias tos pačios paslaugos užklausas iš eilės:
+
----
$ curl http://172.17.0.11:8000
<h1>This request was processed by host: http-774bb756bb-bbvm9</h1>
$ 
$ curl http://172.17.0.11:8000
<h1>This request was processed by host: http-774bb756bb-qvqkc</h1>
$ 
$ # OK, kitas hosto ID
$ 
$ curl http://172.17.0.11:8000
<h1>This request was processed by host: http-774bb756bb-bbvm9</h1>
$ 
$ curl http://172.17.0.11:8000
<h1>This request was processed by host: http-774bb756bb-jcbgf</h1>
$ 
$ # dar vienas naujas hosto ID
$ 
$ curl http://172.17.0.11:8000
<h1>This request was processed by host: http-774bb756bb-qvqkc</h1>
$ 
----
image::https://asciinema.org/a/462344.svg[link="https://asciinema.org/a/462344?autoplay=1"]
+
{nbsp}


  * Reziume #2:

    - Panaudojau `kubectl` komandas (ir subkomandas), ir:
    
      . startavau klasterį, įgalinau Kubectl CLI;
      . patikrinau nodo būseną: veikia;
      . sukūriau įdiegimą su viena replika komandos `kubectl run ...` pagalba;
      . patikrinau HTTP paslaugos įdiegimo būseną: pradėjo veikti;
      . patikrinau išsamų įdiegimo aprašą: atitinka planą;
      . sukūriau paslaugą paviešindamas HTTP portą kaip `8000/TCP`;
      . patikrinau paslaugos veikimą: atsiliepia be klaidų;
      . sukūriau naują HTTP paslaugos diegimą kitu būdu -- iškart viešinant paslaugos portą;
      . šįkart HTTP portas yra `8001/TCP`;
      . patikrinau paslaugos veikimą: atsiliepia irgi;
      . patikrinau paslaugų sąrašą: naujojo porto nematyti;
      . patikrinau konteinerių sąrašą su Docker komanda:  +
        naujasis portas priklauso "k8s.gcr.io/pause" tipo konteineriui;
      . pakėliau pirmosios paslaugos „ankšties“ kopijų skaičių nuo 1 iki 3;
      . tikrinau jų būsenas ir sulaukiau, kol startuos dvi papildonos;
      . įsitikinau, kad visų trijų paslaugos „ankščių“ HTTP-portai pateko į apkrovos balansavimą;
      . atlikau šiai paslaugai keletą užklausų iš eilės:  +
        įsitikinau, kad atsako skirtingas Host ID (iš trijų galimų);
      . tyrimas baigtas.
    
    - `kubectl run --image= ...` komanda pyksta dėl _Deprecated_ opcijos `--generator`, nors aš tokios nenaudojau.  +
      Ir rekomenduoja naudoti vieną iš dviejų kitokių komandų.
+
=> Turbūt verta parašyti `katacoda` treniruoklio autoriams, kad atėjo metas atnaujinti instrukcijas. :)

    - Tikėtina, kad _Docker Port Mapping_ mechanizmas veikia būtent taip minima punkte nr. 12.  +
      Tačiau nežinau, kaip įsitikinti garantuotai, kad jis čia panaudotas.

    - Pasigedau veiksmo, kuriame būtume kurę replikavimo valdiklius, kaip žadėta scenarijaus aprašyme.    

<<<

=== Scenarijus nr. 3: "*Deploy Containers Using YAML*"

  * Trumpas aprašymas

Mokinsimės Kubectl pagalba kurti ir startuoti įdiegimus, replikavimo valdiklius ir viešinti juos kaip paslaugas šįkart _jau_ pasinaudojant YAML apibrėžtimis (YAML formatu).

YAML apibrėžtimis aprašomi Kubernetes objektai, paskirti įdiegimams.
Taip pat bus ir galimybė keičiantis konfigūracijai šiuos objektus atnaujinti bei perdiegti į klasterį iš naujo.


  * Žingsnis 3.1: *įdiegimo kūrimas*

    - automatinis klasterio startas su _Shell_:
+
----
Your Interactive Bash Terminal. A safe place to learn and execute commands.

$ minikube start --wait=false
* minikube v1.8.1 on Ubuntu 18.04
* Using the none driver based on user configuration
* Running on localhost (CPUs=2, Memory=2460MB, Disk=145651MB) ...
* OS release is Ubuntu 18.04.4 LTS
* Preparing Kubernetes v1.17.3 on Docker 19.03.6 ...
  - kubelet.resolv-conf=/run/systemd/resolve/resolv.conf
* Launching Kubernetes ... 
* Enabling addons: default-storageclass, storage-provisioner
* Configuring local host environment ...
* Done! kubectl is now configured to use "minikube"
$ 
----
+
{nbsp}


    - įkeliu YAML šabloną `deployment.yaml`:
+
----
$ ls -l
total 8
-rw-r--r-- 1 root root  335 Jan 17 22:37 deployment.yaml
drwxr-xr-x 2 root root 4096 Mar  1  2020 Desktop

$ cat deployment.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp1
spec:
  replicas: 1
  selector:
    matchLabels:
      app: webapp1
  template:
    metadata:
      labels:
        app: webapp1
    spec:
      containers:
      - name: webapp1
        image: katacoda/docker-http-server:latest
        ports:
        - containerPort: 80
$ 
----
image::https://asciinema.org/a/462387.svg[link="https://asciinema.org/a/462387?autoplay=1"]
+
{nbsp}


    - į klasterį diegiu aplikaciją `webapp1` iš Doker atvaizdo `katacoda/docker-http-server:latest`:
+
----
$ kubectl create -f deployment.yaml
deployment.apps/webapp1 created
$ 
----
image::https://asciinema.org/a/462388.svg[link="https://asciinema.org/a/462388?autoplay=1"]
+
{nbsp}


    - peržiūriu įdiegimų sąrašą:
+
----
$ kubectl get deployment
NAME      READY   UP-TO-DATE   AVAILABLE   AGE
webapp1   1/1     1            1           4m37s
$ 
----
image::https://asciinema.org/a/462389.svg[link="https://asciinema.org/a/462389?autoplay=1"]
+
{nbsp}


    - peržiūriu `webapp1` įdiegimo aprašą:
+
----
$ kubectl describe deployment webapp1
Name:                   webapp1
Namespace:              default
CreationTimestamp:      Mon, 17 Jan 2022 22:45:45 +0000
Labels:                 <none>
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               app=webapp1
Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=webapp1
  Containers:
   webapp1:
    Image:        katacoda/docker-http-server:latest
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  <none>
NewReplicaSet:   webapp1-6b54fb89d9 (1/1 replicas created)
Events:
  Type    Reason             Age    From                   Message
  ----    ------             ----   ----                   -------
  Normal  ScalingReplicaSet  6m55s  deployment-controller  Scaled up replica set webapp1-6b54fb89d9 to 1
$ 
----
image::https://asciinema.org/a/462390.svg[link="https://asciinema.org/a/462390?autoplay=1"]
+
{nbsp}


  * Žingsnis 3.2: *paslaugos kūrimas*

    - įkeliu YAML šabloną `service.yaml`:
+
----
$ ls -l
total 12
-rw-r--r-- 1 root root  335 Jan 17 22:37 deployment.yaml
drwxr-xr-x 2 root root 4096 Mar  1  2020 Desktop
-rw-r--r-- 1 root root  180 Jan 17 22:57 service.yaml

$ cat service.yaml
apiVersion: v1
kind: Service
metadata:
  name: webapp1-svc
  labels:
    app: webapp1
spec:
  type: NodePort
  ports:
  - port: 80
    nodePort: 30080
  selector:
    app: webapp1
$ 
----
image::https://asciinema.org/a/462391.svg[link="https://asciinema.org/a/462391?autoplay=1"]
+
{nbsp}


    - įdiegiu paslaugą:
+
----
$ kubectl create -f service.yaml
service/webapp1-svc created
$ 
----
image::https://asciinema.org/a/462392.svg[link="https://asciinema.org/a/462392?autoplay=1"]
+
{nbsp}


    - peržiūriu įdiegtų paslaugų sąrašą:
+
----
$ kubectl get svc
NAME          TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
kubernetes    ClusterIP   10.96.0.1       <none>        443/TCP        28m
webapp1-svc   NodePort    10.105.23.172   <none>        80:30080/TCP   100s
$ 
----
image::https://asciinema.org/a/462393.svg[link="https://asciinema.org/a/462393?autoplay=1"]
+
{nbsp}


    - peržiūriu paslaugos `webapp1-svc` aprašą:
+
----
$ kubectl describe svc webapp1-svc
Name:                     webapp1-svc
Namespace:                default
Labels:                   app=webapp1
Annotations:              <none>
Selector:                 app=webapp1
Type:                     NodePort
IP:                       10.105.23.172
Port:                     <unset>  80/TCP
TargetPort:               80/TCP
NodePort:                 <unset>  30080/TCP
Endpoints:                172.18.0.4:80
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   <none>
$ 
----
image::https://asciinema.org/a/462397.svg[link="https://asciinema.org/a/462397?autoplay=1"]
+
{nbsp}


    - tikrinu paslaugos veikimą:
+
----
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-qz98l</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-qz98l</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-qz98l</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-qz98l</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-qz98l</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-qz98l</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-qz98l</h1>
$ 
----
image::https://asciinema.org/a/462398.svg[link="https://asciinema.org/a/462398?autoplay=1"]
+
{nbsp}


  * Žingsnis 3.3: *įdiegimo dauginimas*

    - replikų (egzempliorių) skaičių YAML šablone `deployment.yaml` pakeliu iki 4:
+
----
$ cp -v deployment.yaml deployment.yaml.OLD
'deployment.yaml' -> 'deployment.yaml.OLD'

$ vim deployment.yaml

$ ls -l
total 16
-rw-r--r-- 1 root root  335 Jan 17 23:15 deployment.yaml
-rw-r--r-- 1 root root  335 Jan 17 23:14 deployment.yaml.OLD
drwxr-xr-x 2 root root 4096 Mar  1  2020 Desktop
-rw-r--r-- 1 root root  180 Jan 17 22:57 service.yaml

$ diff -u deployment.yaml.OLD deployment.yaml | colordiff
--- deployment.yaml.OLD 2022-01-17 23:14:54.436000000 +0000
+++ deployment.yaml     2022-01-17 23:15:16.648000000 +0000
@@ -3,7 +3,7 @@
 metadata:
   name: webapp1
 spec:
-  replicas: 1
+  replicas: 4
   selector:
     matchLabels:
       app: webapp1
$ 
----
image::https://asciinema.org/a/462399.svg[link="https://asciinema.org/a/462399?autoplay=1"]
+
{nbsp}


    - padauginu veikiančių replikų (egzempliorių) skaičių:
+
----
$ kubectl apply -f deployment.yaml
Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply
deployment.apps/webapp1 configured
$ 
----
image::https://asciinema.org/a/462400.svg[link="https://asciinema.org/a/462400?autoplay=1"]
+
{nbsp}


    - tikrinu įdiegimo / klasterio būseną:
+
----
$ kubectl get deployment
NAME      READY   UP-TO-DATE   AVAILABLE   AGE
webapp1   4/4     4            4           36m
$ 
----
image::https://asciinema.org/a/462402.svg[link="https://asciinema.org/a/462402?autoplay=1"]
+
{nbsp}


    - tikrinu naujų „ankščių“ būseną:
+
----
$ kubectl get pods
NAME                       READY   STATUS    RESTARTS   AGE
webapp1-6b54fb89d9-27g4g   1/1     Running   0          7m50s
webapp1-6b54fb89d9-2v7vh   1/1     Running   0          7m50s
webapp1-6b54fb89d9-p8lck   1/1     Running   0          7m50s
webapp1-6b54fb89d9-qz98l   1/1     Running   0          40m
$ 
----
image::https://asciinema.org/a/462405.svg[link="https://asciinema.org/a/462405?autoplay=1"]
+
{nbsp}


    - tikrinu užklausas į paslaugą:
+
----
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-2v7vh</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-27g4g</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-2v7vh</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-qz98l</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-27g4g</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-27g4g</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-p8lck</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-27g4g</h1>
$ 
$ curl host01:30080
<h1>This request was processed by host: webapp1-6b54fb89d9-p8lck</h1>
$ 
----
image::https://asciinema.org/a/462404.svg[link="https://asciinema.org/a/462404?autoplay=1"]
+
{nbsp}


  * Reziume #3:

    - Įvykdžiau diegimą pagal YAML šabloną (arba apibrėžtį, angl. _definition_):
    
      . gavau Shell su veikiančiu K8s miniklasteriu;
      . įkėliau `deployment.yaml` šabloną;
      . pagal jį įdiegiau aplikaciją `webapp1` iš Docker atvaizdo `katacoda/docker-http-server`;
      . įsitikinau, kad įdiegimas pavyko;
      . peržiūrėjau jo aprašą, Host Port nenurodytas (`0/TCP`);
      . įkėliau `service.yaml` šabloną;
      . pagal jį įdiegiau HTTP paslaugą `webapp1-svc`;
      . įsitikinau, kad HTTP paslauga sukonfigūruota;
      . peržiūrėjau jos aprašą, Node Port priskirta `30080/TCP` reikšmė;
      . patikrinau paslaugos veikimą: ta pati „ankštis“ atsako visas užklausas iš eilės;
      . padidinau replikų skaičių šablone `deployment.yaml` iki 4;
      . pritaikiau šabloną klasteriui su `kubectl apply` komanda;
      . patikrinau įdiegimo ir „ankščių“ būseną: skaičius pakilo iki 4;
      . patikrinau paslaugos veikimą: į užklausas atsako jau 4 skirtingos „ankštys“;
      . patikrinau paslaugos aprašą: yra visi 4 _Endpoints_  (iš jų vienas neišvestas dėl teksto trumpumo);  +
        (šito ataskaitoje neiliustravau)
      . tyrimas baigtas.

    - Naudojant YAML failus *tampa neaišku*:
    
      . kodėl atsiranda `app` raktažodis ? (Panašu, kad vietoj anksčiau naudoto `run`)
      . ką aprašo `spec.template` ir kas bus, jei **ne**nurodysiu `spec.template.metadata.labels.app` ?  
        (Kai jau tas pat nurodyta pas `spec.selector.app`)
      . kodėl įdiegimo apraše vardą `webapp1` reikia nurodyti net 4x:
        ** `spec.metadata.name` ?
        ** `spec.selector.matchLabels.app` ?
        ** `spec.template.metadata.labels.app` ?
        ** `spec.template.spec.containers.name` ?
      . kodėl TCP portą `80` reikia nurodyti tiek įdiegimui (`spec.template.spec.containers.ports`), tiek paslaugai (`spec.ports.port`), kai per CLI pakakdavo nurodyti tik vieną sykį ?
      . ar paslaugos `spec.selector.app` nurodo įdiegimo konteinerį, ar įdiegimo „ankštį“ (galvojant ne YAML scenarijaus sąvokomis) ?
      . Išvada: YAML šablonai įneša painavios į anksčiau susidarytą pradinį supratimą apie K8s.

    - Komanda `kubectl apply -f ...` pyksta:  +
      `Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply`  +
+
=> Galbūt irgi vertėtų pranešti treniruoklio autoriams (dėl instrukcijų patikslinimo).


<<<

=== Scenarijus nr. 4: "*Deploy Guestbook example (Web App) on Kubernetes*"

  * Trumpas aprašymas

Čia mokinsimės su Kubernetes ir Docker pagalba startuoti paprastą, bet daugiapakopę Web aplikaciją.
Siūlomos „Svečių knygos“ aplikacijos pavyzdys išsaugos puslapio svečių žinutes _Redis_ duomenų bazėje (DB) kviesdamas JavaScript API.
_Redis_ DB susideda iš _masterio_ (duomenų talpinimui) ir rinkinio iš replikuotų Redis _tarnų_.

Numatoma aprėpti tokias esmines sąvokas:

    - „ankštys“
    - replikavimo kontroleriai
    - paslaugos
    - _NodePortai_

Jos sudaro _Kubernetes_ pagrindą.


  * Žingsnis 4.1: *klasterio startavimas*

    - _Shell_ ir automatinis vienanodžio klasterio startas:
+
----
Your Interactive Bash Terminal. A safe place to learn and execute commands.

controlplane $ mkdir -p /root/tutorial; cd /root/tutorial; launch.sh
Waiting for Kubernetes to start...
Kubernetes started
controlplane $ 
----


    - tikrinu klasterio būseną:
+
----
controlplane $ kubectl cluster-info
Kubernetes master is running at https://172.17.0.35:6443
KubeDNS is running at https://172.17.0.35:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.

controlplane $ kubectl get nodes
NAME           STATUS   ROLES    AGE     VERSION
controlplane   Ready    master   6m12s   v1.14.0
node01         Ready    <none>   5m27s   v1.14.0
controlplane $ 
----


  * Žingsnis 4.2: *Redis _master_ kontroleris*

    - peržiūriu YAML aprašą:
+
----
controlplane $ cat redis-master-controller.yaml 
apiVersion: v1
kind: ReplicationController
metadata:
  name: redis-master
  labels:
    name: redis-master
spec:
  replicas: 1
  selector:
    name: redis-master
  template:
    metadata:
      labels:
        name: redis-master
    spec:
      containers:
      - name: master
        image: redis:3.0.7-alpine
        ports:
        - containerPort: 6379
controlplane $ 
----


    - sukuriu ir startuoju Redis _masterio_ replikacinį kontrolerį:
+
----
controlplane $ kubectl create -f redis-master-controller.yaml 
replicationcontroller/redis-master created
controlplane $ 
----


    - tikrinu replikacinių kontrolerių būseną:
+
----
controlplane $ kubectl get rc
NAME           DESIRED   CURRENT   READY   AGE
redis-master   1         1         1       31s
controlplane $ 
----


    - tikrinu „ankščių“ / konteinerių būseną:
+
----
controlplane $ kubectl get pods
NAME                 READY   STATUS    RESTARTS   AGE
redis-master-zrnbw   1/1     Running   0          2m38s
controlplane $ 
----


  * Žingsnis 4.3: *Redis _master_ paslauga*

    - peržiūriu YAML aprašą:
+
----
controlplane $ cat redis-master-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: redis-master
  labels:
    name: redis-master
spec:
  ports:
    # the port that this service should serve on
  - port: 6379
    targetPort: 6379
  selector:
    name: redis-master
controlplane $ 
----


    - sukuriu ir startuoju Redis _masterio_ paslaugą:
+
----
controlplane $ kubectl create -f redis-master-service.yaml 
service/redis-master created
controlplane $ 
----


    - tikrinu paslaugų būseną:
+
----
controlplane $ kubectl get services
NAME           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
kubernetes     ClusterIP   10.96.0.1      <none>        443/TCP    20m
redis-master   ClusterIP   10.96.47.163   <none>        6379/TCP   82s
controlplane $ 
----


    - peržiūriu Redis _masterio_ paslaugos aprašą:
+
----
controlplane $ kubectl describe services redis-master
Name:              redis-master
Namespace:         default
Labels:            name=redis-master
Annotations:       <none>
Selector:          name=redis-master
Type:              ClusterIP
IP:                10.96.47.163
Port:              <unset>  6379/TCP
TargetPort:        6379/TCP
Endpoints:         10.32.0.193:6379
Session Affinity:  None
Events:            <none>
controlplane $ 
----


  * Žingsnis 4.4: *Redis _tarnų_ kontroleris*

    - peržiūriu YAML aprašą:
+
----
controlplane $ cat redis-slave-controller.yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: redis-slave
  labels:
    name: redis-slave
spec:
  replicas: 2
  selector:
    name: redis-slave
  template:
    metadata:
      labels:
        name: redis-slave
    spec:
      containers:
      - name: worker
        image: gcr.io/google_samples/gb-redisslave:v1
        env:
        - name: GET_HOSTS_FROM
          value: dns
          # If your cluster config does not include a dns service, then to
          # instead access an environment variable to find the master
          # service's host, comment out the 'value: dns' line above, and
          # uncomment the line below.
          # value: env
        ports:
        - containerPort: 6379
controlplane $ 
----


    - sukuriu ir startuoju Redis _tarnų_ replikacinį kontrolerį:
+
----
controlplane $ kubectl create -f redis-slave-controller.yaml
replicationcontroller/redis-slave created
----


    - tikrinu replikacinių kontrolerių būseną:
+
----
controlplane $ kubectl get rc
NAME           DESIRED   CURRENT   READY   AGE
redis-master   1         1         1       14m
redis-slave    2         2         0       3s

controlplane $ kubectl get rc
NAME           DESIRED   CURRENT   READY   AGE
redis-master   1         1         1       14m
redis-slave    2         2         2       5s
controlplane $ 
----


  * Žingsnis 4.5: *Redis _tarnų_ paslauga*

    - peržiūriu YAML aprašą:
+
----
controlplane $ cat redis-slave-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: redis-slave
  labels:
    name: redis-slave
spec:
  ports:
    # the port that this service should serve on
  - port: 6379
  selector:
    name: redis-slave
----


    - sukuriu ir startuoju Redis _tarnų_ paslaugą:
+
----
controlplane $ kubectl create -f redis-slave-service.yaml
service/redis-slave created
----


    - tikrinu paslaugų būseną:
+
----
controlplane $ kubectl get services
NAME           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
kubernetes     ClusterIP   10.96.0.1      <none>        443/TCP    33m
redis-master   ClusterIP   10.96.47.163   <none>        6379/TCP   14m
redis-slave    ClusterIP   10.111.48.51   <none>        6379/TCP   74s
----


    - patikrinu ir „ankščių“ būsenas:
+
----
controlplane $ kubectl get pods
NAME                 READY   STATUS    RESTARTS   AGE
redis-master-zrnbw   1/1     Running   0          22m
redis-slave-9lc9b    1/1     Running   0          7m31s
redis-slave-x8mk8    1/1     Running   0          7m31s
----


  * Žingsnis 4.6: *Frontendas -- replikacinis valdiklis ir jo „ankštys“*

    - :
+
----
