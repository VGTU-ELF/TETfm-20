Debesų kompiuterija

[.text-center]
=== Laboratorinis darbas nr. 2


[.text-center]
== Susipažinimas su Docker konteineriais


[.text-left]
=== Darbo tikslas

* Naudotis pagrindinėmis _Docker_ funkcijomis.
* Iš pirminio failo sukurti ir vykdyti konteinerio atvaizdį (angl. _Image).


[.text-left]
=== Įvadas. Kas yra _Docker_?

_Docker_ -- įrankis aplikacijų kūrimo, diegimo ir vykdymo palengvinimui, naudojantis konteinerizavimo principą.

Konteineriai įgalina kūrėjus supakuoti aplikaciją su visomis jai reikiamomis dalimis,
pvz. bibliotekomis ir kitais priklausomumais (angl. _Dependencies_),
ir išsiųsti ją diegimams kaip vientisą pakuotę.

Konteinerizavimo technologijos dėka šis būdas kūrėjui užtikrina,
kad aplikacija veiks bet kurioje kitoje _Linux_ mašinoje,
ir tas veikimas nepriklausys nuo jokių individualizuotų šios mašinos nustatymų (nuostatų), besiskiriančių atžvilgiu tos mašinos, kur aplikacija buvo kuriama ar testuojama.

Daugiau: <<1>>


[.text-left]
=== Užduotys

==== Užduotis nr. 1: **Prisijungimas prie Jūsų virtualaus serverio**


. Panaudokite SSH klientinę programą ir prisijunkite prie virtualaus serverio:
+
|===
      ^| Hostname   ^| Service    ^| IP                                          ^| TCP port
  
  .2+.^| `cc-lab`    | SSH    .2+.^| {nbsp} `1~y~8.1~z~9.200.236` ^*^ {nbsp}      | `45~x~22` ^*^
                     | HTTP                                                       | `45~x~80` ^*^
|===
+
$$*$$  -- `~x~`, `~y~` ir `~z~` reikšmes pateiks dėstytojas.
+
{nbsp}

. Jūsų laboratorinės aplinkos sujungimų diagrama:
+
image::https://raw.githubusercontent.com/VGTU-ELF/TETfm-20/main/Semestras-3/2-Debes%C5%B3-kompiuterija/laboratoriniai-darbai/LD2-pav1-laboratorin%C4%97-aplinka.svg[]

. Prisijunkite prie savo virtualios mašinos (VM) panaudojant dėstytojo nurodytus kredencialus.


==== Užduotis nr. 2: **_Docker_ tyrinėjimas**

. Patikrinkite _Docker_ įdiegtumą ir veikimą:
+
----
$ sudo docker --version
----

. Startuokite pavyzdinį atvaizdį:
+
----
$ sudo docker run hello-world
----
+
Turėtumėte matyti panašią išvestį:
+
----
Hello from Docker!

This message shows that your installation appears to be working correctly.

<...>
----
+
---
+
_Docker_ turi daug komandų ir jų parametrų, ir karts nuo karto jie pasikeičia.
Paskutinis komandinės eilutės formato (CLI, angl. _Command line interface_) pokytis įvyko 2017 m. sausį.
+
CLI komandos buvo suskirstytos į funkcines valdymo grupes.
Pvz. dabar yra atskiros konteinerio valdymo ir atvaizdžio valdymo komandų grupės.
+
Šis pokytis pakeitė _Docker_ komandų sudarymo stilių.
Pvz. taip naudojama naujoji `run` komanda:
+
----
$ sudo docker container run hello-world
----
+
Tokiu būdu efektyvėja komandos sąranga, tačiau šiek tiek išauga CLI daugžodiškumas.
O senoji komandų sintaksė kol kas vis dar veikia (visoms _Docker_ subkomandoms).
+
_Docker_ atvaizdžiai iš esmės yra savarankiški paketai, sutalpinantys viską, ko reikia tos aplikacijos vykdymui.
Vienas iš didžiausių privalumų -- _Docker_ atvaizdžiai veikia beveik bet kurioje^**^ operacijų sistemoje (OS).  +
+
_Docker_ buvo kurtas naudojantis Linux OS ir yra stipriai integruotas su kertiniais Linux konstruktais.
Tad _Docker_ vykdant Linux sistemose, veiksmai į OS integruojasi sklandžiai ir tiesiogiai.
_Docker_ mechanizmas Linux branduolį ir failų sistemą (FS) išnaudoja pri**gim**tinai.

$$**$$ -- Šiuo teiginiu patikėti sunku: _Docker_ įrankis
FreeBSD neveikia,
NetBSD neveikia,
Solaris OS neveikia,
HP-UXe neveikia,
AIXe neveikia,
OpenVMSe neveikia.
Omenyje turiu scenarijus be papildomų VM kūrimo / be hipervizoriaus / be mašinos emuliacijos.


. Pastarajame pavyzdyje _Docker_ atvaizdis `hello-world` sistemoje jau buvo įdiegtas.
Bendru atveju, kai komanda `run` vykdoma pirmą sykį, 
ji peržiūri vietinę atvaizdžių talpyklą (angl. _Local image cache_) ir tikrina,
ar joje jau yra konteinerinis atvaizdis tokiu vardu.
+
Jeigu randa, _Docker_ startuoja konteinerį iš talpyklinio atvaizdžio.
Jei neranda, _Docker_ jungiasi prie _Docker registro_ (https://hub.docker.com, primena GitHub sistemą)
ir bando tokį atvaizdį parsisiųsti ir išsaugoti vietinėje talpykloje.
+
Pamėginkite šiame registre paieškoti Ubuntu atvaizdžių:
+
----
$ sudo docker search ubuntu
----

. Mašinoje veikiantys (jau startavę) konteineriai parodomi šia komanda:
+
----
$ sudo docker container ls
----
+
Kol kas turėtumėte gauti tuščią sąrašą.

. Dabar turite dvi galimybes -- arba parsitempti ir startuoti atvaizdį..:
+
----
$ sudo docker image pull ubuntu
$ sudo docker container run ubuntu
----

. ... arba tiesiog startuoti pasirinktą atvaizdį, ir jis bus partemptas (parsiųstas ir išsaugotas) automatiškai:
+
----
$ sudo docker container run busybox
----
+
Abiem atvejais kai paskutinė komanda yra nutraukiama, konteineriai yra sustabdomi ir baigia darbą.

. Pamėginkite komandoje pridėti papildomą raktą:
+
----
$ sudo docker container run -it busybox
----
+
Interaktyvių procesų (pvz. įprastinės *nix Shell aplinkos) atveju tenka panaudoti `-i` ir `-t` raktus kartu,
kad konteineriui būtų priskirtas terminalas (terminalinis vardas).
+
Šitaip pasiekiate _Bash_ aplinką Ubuntu konteineryje, veikiančiame jūsų mašinoje.
Dabar jis Jūsų rūpestyje -- gavote galimybę užsiimti dalykų diegimu, vykdyti programas ir užsiimti čia apskritai kuo tik sugalvojate.

. Atverkite **papildomą** terminalą ir peržiūrėkite veikiančius konteinerius:
+
----
$ sudo docker container ls
----
+
Ką dabar matote, kas pasikeitė?
+
Prisiminkite, kad reikia iš konteinerio ir išeiti.

. Įprastai konteineriai viduje neturi nuosavos diskinės vietos.
Pabandykime prijungti _Docker_ hosto direktoriją prie _Docker_ konteinerio.
Pirmiausiai savo pradinėje (angl. _Home_) direktorijoje sukurkite subdirektoriją, pavadinkite savo nuožiūra:
+
----
$ mkdir test_directory
$ touch test_directory/test.file
----

. Startuokite konteinerį (guestą):
+
----
$ sudo docker container run -it -v /home/stud/test_directory:/TEST ubuntu
----
+
Čia `/home/stud/test_directory` yra absoliutus Jūsų direktorijos kelias.
Įstikinimui naudokite komandą `pwd`.
+
Jei dabar konteineryje surinksite komandą `ls`, turėtumėte pamatyti Guest direktoriją `TEST`, kuri tiesiogiai susieta su hosto direktorija.
+
Ar pavyko ją pamatyti?


==== Užduotis nr. 3: **_Web_-serviso atvaizdžio sukūrimas pagal _Dockerfile_**

. Parašykime šiek tiek kodo -- `bottle` bibliotekos pagrindu sukurkime paprasčiausią aplikaciją.
Pagrindinis failas `main_app.py` parodytas žemiau.
Tai _Web_-servisas su dviem galiniais taškais.
+
Šakniniame galutiniame taške (angl. _root endpoint_) yra paprastas _hello world_ puslapis.
Jis naudoja `index.tpl` šabloną, laikomą repozitorijos _"views"_ skiltyje
ir aptarnauja virtualų _Docker_ konteinerio IP adresą.
+
Sukurkite naują direktoriją:
+
----
$ mkdir ~/src
$ cd ~/src
----
+
\... o joje patalpinkite nurodytą failą:
+
[source,python]
----
#!/usr/bin/env python
import bottle
import subprocess
import os

ip_addr = '123.45.67.89'

app = bottle.app()

@bottle.route("/")

def root_index():
    return bottle.template('index', ip_addr = ip_addr)

@bottle.route('/json')

def json_reply():
    head = bottle.request.headers
    bottle.response.content_type = 'application/json'
    
    response = {
        'headers'     : dict(heads),
        'environment' : dict(os.environ),
        'response'    : dict(bottle.response.headers)
    }
    return response

if __name__ == '__main__':
    bottle.debug(True)
    bottle.run(app=app, jost='0.0.0.0', port=8080)
----

. Kitame faile, `views/index.tpl` laikomas šakninio puslapio šablonas.
Jame panaudota paprasta šabloninė kalba:
+
[source,html]
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Hello World</title>
  </head>
  <body>
    <h1>Hello World!</h1>
    <h2>From Docker and Bottle</h2>
    <p>This service is running in a Docker container with a virtual IP address of {{ip_addr}}.</p>
  </body>
</html>
----
+
Sukurkite ir jį.

. Paruoškite pildymui failą `Dockerfile`, skirtą sukurti atvaizdžiui, iš kurio startuos aplikacija (_Web_-servisas).
+
----
$ nano Dockerfile
  ...
----
+
Štai jo turinys:
+
[source,dockerfile]
----
FROM ubuntu:14:04
MAINTAINER yourname <youre@stud.vilniustech.lt>

RUN apt-get update && apt-get install -y python-pip python-dev && apt-get clean

# set the working directory in the container to /app:
WORKDIR /app

# add the current directory in the container to /app:
ADD . /app

# execute everyone's favorite pip commands:
RUN pip install bottle

# unblock port 8080 for the bottle app to run on:
EXPOSE 8080

# execute the app:
CMD ["python", "main_app.py"]
----
+
Šis `Dockerfile` išviešina TCP protą `8080`, patalpina aplikaciją į `/app` direktoriją atvaizdžio viduje ir paruošia `python` procesą, kad pagal nutylėjimą vykdytų mūsų pasirinktą skriptą `main_app.py`.

TODO

==== Ataskaitos turinys:

  * Aprašyti pasiekti  rezultatai kiekvienoje užduotyje.
  * Iliustracija, kad Jūsų tinklalapis pasiekiamas internetu.
  * Laikykitės principo: _Less is more_. Svarbu kokybė.
  * Išlaikykite vienodą stilių.
  * Failo dydis < 5 MiB, formatas `PDF`, talpinimo vieta: _Moodle_.


[bibliography]
==== Nuorodos

`2020<04-01` **[[[1]]]** `opensource.com`, (atnaujinta) Red Hat, Inc. https://opensource.com/resources/what-docker[What is Docker?]
